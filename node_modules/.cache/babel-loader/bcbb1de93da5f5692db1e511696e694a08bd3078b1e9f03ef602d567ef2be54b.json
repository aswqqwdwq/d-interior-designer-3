{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { Instances, Instance } from './Instances.js';\nimport { Billboard } from './Billboard.js';\nimport { useSpriteLoader, getFirstFrame } from './useSpriteLoader.js';\n\n// Frame-related types\n\nconst context = /*#__PURE__*/React.createContext(null);\nfunction useSpriteAnimator() {\n  return React.useContext(context);\n}\n\n// Type guard for SpriteData\nfunction isSpriteData(data) {\n  return data !== null && 'meta' in data && 'frames' in data;\n}\nconst geometry = new THREE.PlaneGeometry(1, 1);\nconst SpriteAnimator = /* @__PURE__ */React.forwardRef((_ref2, fref) => {\n  let {\n    startFrame = 0,\n    endFrame,\n    fps = 30,\n    frameName = '',\n    textureDataURL,\n    textureImageURL,\n    loop = false,\n    numberOfFrames = 1,\n    autoPlay = true,\n    animationNames,\n    onStart,\n    onEnd,\n    onLoopEnd,\n    onFrame,\n    play,\n    pause = false,\n    flipX = false,\n    alphaTest = 0.0,\n    children,\n    asSprite = false,\n    offset,\n    playBackwards = false,\n    resetOnEnd = false,\n    maxItems = 1,\n    instanceItems = [[0, 0, 0]],\n    spriteDataset,\n    canvasRenderingContext2DSettings,\n    roundFramePosition = false,\n    meshProps = {},\n    ...props\n  } = _ref2;\n  const ref = React.useRef(new THREE.Group());\n  const spriteData = React.useRef(null);\n  const matRef = React.useRef(null);\n  const spriteRef = React.useRef(null);\n  const timerOffset = React.useRef(window.performance.now());\n  const currentFrame = React.useRef(startFrame);\n  const currentFrameName = React.useRef(frameName);\n  const fpsInterval = fps > 0 ? 1000 / fps : 0;\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const totalFrames = React.useRef(0);\n  const [aspect, setAspect] = React.useState(new THREE.Vector3(1, 1, 1));\n  const flipOffset = flipX ? -1 : 1;\n  const pauseRef = React.useRef(pause);\n  const pos = React.useRef(offset);\n  const softEnd = React.useRef(false);\n  const {\n    spriteObj,\n    loadJsonAndTexture\n  } = useSpriteLoader(null, null, animationNames, numberOfFrames, undefined, canvasRenderingContext2DSettings);\n  const frameNameRef = React.useRef(frameName);\n\n  // lite version for pre-loaded assets\n  const parseSpriteDataLite = React.useCallback((textureData, data) => {\n    if (data === null) {\n      if (numberOfFrames) {\n        //get size from texture\n\n        totalFrames.current = numberOfFrames;\n        if (playBackwards) {\n          currentFrame.current = numberOfFrames - 1;\n        }\n        spriteData.current = data;\n      }\n    } else {\n      var _spriteData$current$f, _spriteData$current;\n      spriteData.current = data;\n      if (spriteData.current && Array.isArray(spriteData.current.frames)) {\n        totalFrames.current = spriteData.current.frames.length;\n      } else if (spriteData.current && typeof spriteData.current === 'object' && frameNameRef.current) {\n        totalFrames.current = spriteData.current.frames[frameNameRef.current].length;\n      } else {\n        totalFrames.current = 0;\n      }\n      if (playBackwards) {\n        currentFrame.current = totalFrames.current - 1;\n      }\n      const {\n        w,\n        h\n      } = getFirstFrame((_spriteData$current$f = (_spriteData$current = spriteData.current) == null ? void 0 : _spriteData$current.frames) !== null && _spriteData$current$f !== void 0 ? _spriteData$current$f : [], frameNameRef.current).sourceSize;\n      const aspect = calculateAspectRatio(w, h);\n      setAspect(aspect);\n      if (matRef.current) {\n        matRef.current.map = textureData;\n      }\n    }\n    setSpriteTexture(textureData);\n  }, [numberOfFrames, playBackwards]);\n\n  // modify the sprite material after json is parsed and state updated\n  const modifySpritePosition = React.useCallback(() => {\n    if (!spriteData.current) return;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = Array.isArray(frames) ? frames[0].sourceSize : frameName ? frames[frameName] ? frames[frameName][0].sourceSize : {\n      w: 0,\n      h: 0\n    } : {\n      w: 0,\n      h: 0\n    };\n    if (matRef.current && matRef.current.map) {\n      matRef.current.map.wrapS = matRef.current.map.wrapT = THREE.RepeatWrapping;\n      matRef.current.map.center.set(0, 0);\n      matRef.current.map.repeat.set(1 * flipOffset / (metaInfo.w / frameW), 1 / (metaInfo.h / frameH));\n    }\n    //const framesH = (metaInfo.w - 1) / frameW\n    const framesV = (metaInfo.h - 1) / frameH;\n    const frameOffsetY = 1 / framesV;\n    if (matRef.current && matRef.current.map) {\n      matRef.current.map.offset.x = 0.0; //-matRef.current.map.repeat.x\n      matRef.current.map.offset.y = 1 - frameOffsetY;\n    }\n    if (onStart) {\n      onStart({\n        currentFrameName: frameName !== null && frameName !== void 0 ? frameName : '',\n        currentFrame: currentFrame.current\n      });\n    }\n  }, [flipOffset, frameName, onStart]);\n  const state = React.useMemo(() => ({\n    current: pos.current,\n    offset: pos.current,\n    imageUrl: textureImageURL,\n    hasEnded: false,\n    ref: fref\n  }), [textureImageURL, fref]);\n  React.useImperativeHandle(fref, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    pos.current = offset;\n  }, [offset]);\n  const calculateAspectRatio = (width, height) => {\n    var _spriteRef$current;\n    const ret = new THREE.Vector3();\n    const aspectRatio = height / width;\n    ret.set(1, aspectRatio, 1);\n    (_spriteRef$current = spriteRef.current) == null || _spriteRef$current.scale.copy(ret);\n    return ret;\n  };\n\n  // initial loads\n  React.useEffect(() => {\n    if (spriteDataset) {\n      var _spriteDataset$sprite;\n      parseSpriteDataLite(spriteDataset == null || (_spriteDataset$sprite = spriteDataset.spriteTexture) == null ? void 0 : _spriteDataset$sprite.clone(), spriteDataset.spriteData);\n    } else {\n      if (textureImageURL && textureDataURL) {\n        loadJsonAndTexture(textureImageURL, textureDataURL);\n      }\n    }\n  }, [loadJsonAndTexture, spriteDataset, textureDataURL, textureImageURL, parseSpriteDataLite]);\n  React.useEffect(() => {\n    if (spriteObj) {\n      var _spriteObj$spriteText;\n      parseSpriteDataLite(spriteObj == null || (_spriteObj$spriteText = spriteObj.spriteTexture) == null ? void 0 : _spriteObj$spriteText.clone(), spriteObj == null ? void 0 : spriteObj.spriteData);\n    }\n  }, [spriteObj, parseSpriteDataLite]);\n\n  // support backwards play\n  React.useEffect(() => {\n    state.hasEnded = false;\n    if (spriteData.current && playBackwards === true) {\n      var _ref;\n      currentFrame.current = ((_ref = spriteData.current.frames.length) !== null && _ref !== void 0 ? _ref : 0) - 1;\n    } else {\n      currentFrame.current = 0;\n    }\n  }, [playBackwards, state]);\n  React.useLayoutEffect(() => {\n    modifySpritePosition();\n  }, [spriteTexture, flipX, modifySpritePosition]);\n  React.useEffect(() => {\n    if (autoPlay) {\n      pauseRef.current = false;\n    }\n  }, [autoPlay]);\n  React.useLayoutEffect(() => {\n    if (currentFrameName.current !== frameName && frameName) {\n      currentFrame.current = 0;\n      currentFrameName.current = frameName;\n      state.hasEnded = false;\n      if (fpsInterval <= 0) {\n        currentFrame.current = endFrame || startFrame || 0;\n      }\n      // modifySpritePosition()\n      if (spriteData.current) {\n        const {\n          w,\n          h\n        } = getFirstFrame(spriteData.current.frames, frameName).sourceSize;\n        const _aspect = calculateAspectRatio(w, h);\n        setAspect(_aspect);\n      }\n    }\n  }, [frameName, fpsInterval, state, endFrame, startFrame]);\n\n  // run the animation on each frame\n  const runAnimation = () => {\n    if (!isSpriteData(spriteData.current)) return;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = getFirstFrame(frames, frameName).sourceSize;\n    const spriteFrames = Array.isArray(frames) ? frames : frameName ? frames[frameName] : [];\n    const _endFrame = endFrame || spriteFrames.length - 1;\n    var _offset = offset === undefined ? state.current : offset;\n    if (fpsInterval <= 0) {\n      currentFrame.current = endFrame || startFrame || 0;\n      calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n      return;\n    }\n    const now = window.performance.now();\n    const diff = now - timerOffset.current;\n    if (diff <= fpsInterval) return;\n\n    // conditionals to support backwards play\n    var endCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current > _endFrame;\n    var onStartCondition = playBackwards ? currentFrame.current === _endFrame : currentFrame.current === 0;\n    var manualProgressEndCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current >= _endFrame;\n    if (endCondition) {\n      currentFrame.current = loop ? startFrame !== null && startFrame !== void 0 ? startFrame : 0 : 0;\n      if (playBackwards) {\n        currentFrame.current = _endFrame;\n      }\n      if (loop) {\n        onLoopEnd == null || onLoopEnd({\n          currentFrameName: frameName !== null && frameName !== void 0 ? frameName : '',\n          currentFrame: currentFrame.current\n        });\n      } else {\n        onEnd == null || onEnd({\n          currentFrameName: frameName !== null && frameName !== void 0 ? frameName : '',\n          currentFrame: currentFrame.current\n        });\n        state.hasEnded = !resetOnEnd;\n        if (resetOnEnd) {\n          pauseRef.current = true;\n          //calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames)\n        }\n      }\n      if (!loop) return;\n    } else if (onStartCondition) {\n      onStart == null || onStart({\n        currentFrameName: frameName !== null && frameName !== void 0 ? frameName : '',\n        currentFrame: currentFrame.current\n      });\n    }\n\n    // for manual update\n    if (_offset !== undefined && manualProgressEndCondition) {\n      if (softEnd.current === false) {\n        onEnd == null || onEnd({\n          currentFrameName: frameName !== null && frameName !== void 0 ? frameName : '',\n          currentFrame: currentFrame.current\n        });\n        softEnd.current = true;\n      }\n    } else {\n      // same for start?\n      softEnd.current = false;\n    }\n\n    // clock to limit fps\n    if (diff <= fpsInterval) return;\n    timerOffset.current = now - diff % fpsInterval;\n    calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n  };\n  const calculateFinalPosition = (frameW, frameH, metaInfo, spriteFrames) => {\n    // get the manual update offset to find the next frame\n    var _offset = offset === undefined ? state.current : offset;\n    const targetFrame = currentFrame.current;\n    let finalValX = 0;\n    let finalValY = 0;\n    calculateAspectRatio(frameW, frameH);\n    const framesH = roundFramePosition ? Math.round((metaInfo.w - 1) / frameW) : (metaInfo.w - 1) / frameW;\n    const framesV = roundFramePosition ? Math.round((metaInfo.h - 1) / frameH) : (metaInfo.h - 1) / frameH;\n    if (!spriteFrames[targetFrame]) {\n      return;\n    }\n    const {\n      frame: {\n        x: frameX,\n        y: frameY\n      },\n      sourceSize: {\n        w: originalSizeX,\n        h: originalSizeY\n      }\n    } = spriteFrames[targetFrame];\n    const frameOffsetX = 1 / framesH;\n    const frameOffsetY = 1 / framesV;\n    if (matRef.current && matRef.current.map) {\n      finalValX = flipOffset > 0 ? frameOffsetX * (frameX / originalSizeX) : frameOffsetX * (frameX / originalSizeX) - matRef.current.map.repeat.x;\n      finalValY = Math.abs(1 - frameOffsetY) - frameOffsetY * (frameY / originalSizeY);\n      matRef.current.map.offset.x = finalValX;\n      matRef.current.map.offset.y = finalValY;\n    }\n\n    // if manual update is active\n    if (_offset !== undefined && _offset !== null) {\n      // Calculate the frame index, based on offset given from the provider\n      let frameIndex = Math.floor(_offset * spriteFrames.length);\n\n      // Ensure the frame index is within the valid range\n      frameIndex = Math.max(0, Math.min(frameIndex, spriteFrames.length - 1));\n      if (isNaN(frameIndex)) {\n        frameIndex = 0; //fallback\n      }\n      currentFrame.current = frameIndex;\n    } else {\n      // auto update\n      if (playBackwards) {\n        currentFrame.current -= 1;\n      } else {\n        currentFrame.current += 1;\n      }\n    }\n  };\n\n  // *** Warning! It runs on every frame! ***\n  useFrame((_state, _delta) => {\n    var _spriteData$current2, _matRef$current;\n    if (!((_spriteData$current2 = spriteData.current) != null && _spriteData$current2.frames) || !((_matRef$current = matRef.current) != null && _matRef$current.map)) {\n      return;\n    }\n    if (pauseRef.current) {\n      return;\n    }\n    if (!state.hasEnded && (autoPlay || play)) {\n      runAnimation();\n      onFrame == null || onFrame({\n        currentFrameName: currentFrameName.current,\n        currentFrame: currentFrame.current\n      });\n    }\n  });\n  function multiplyScale() {\n    let initialScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new THREE.Vector3(1, 1, 1);\n    let newScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    if (typeof newScale === 'number') return initialScale.multiplyScalar(newScale);\n    if (Array.isArray(newScale)) return initialScale.multiply(new THREE.Vector3(...newScale));\n    if (newScale instanceof THREE.Vector3) return initialScale.multiply(newScale);\n  }\n  return /*#__PURE__*/React.createElement(\"group\", _extends({}, props, {\n    ref: ref,\n    scale: multiplyScale(aspect, props.scale)\n  }), /*#__PURE__*/React.createElement(context.Provider, {\n    value: state\n  }, asSprite && /*#__PURE__*/React.createElement(Billboard, null, /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: spriteRef,\n    scale: 1.0,\n    geometry: geometry\n  }, meshProps), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    premultipliedAlpha: false,\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }))), !asSprite && /*#__PURE__*/React.createElement(Instances, _extends({\n    geometry: geometry,\n    limit: maxItems !== null && maxItems !== void 0 ? maxItems : 1\n  }, meshProps), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    premultipliedAlpha: false,\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }), (instanceItems !== null && instanceItems !== void 0 ? instanceItems : [0]).map((item, index) => /*#__PURE__*/React.createElement(Instance, _extends({\n    key: index,\n    ref: (instanceItems == null ? void 0 : instanceItems.length) === 1 ? spriteRef : null,\n    position: item,\n    scale: 1.0\n  }, meshProps)))), children));\n});\nexport { SpriteAnimator, useSpriteAnimator };","map":{"version":3,"names":["_extends","React","useFrame","THREE","Instances","Instance","Billboard","useSpriteLoader","getFirstFrame","context","createContext","useSpriteAnimator","useContext","isSpriteData","data","geometry","PlaneGeometry","SpriteAnimator","forwardRef","_ref2","fref","startFrame","endFrame","fps","frameName","textureDataURL","textureImageURL","loop","numberOfFrames","autoPlay","animationNames","onStart","onEnd","onLoopEnd","onFrame","play","pause","flipX","alphaTest","children","asSprite","offset","playBackwards","resetOnEnd","maxItems","instanceItems","spriteDataset","canvasRenderingContext2DSettings","roundFramePosition","meshProps","props","ref","useRef","Group","spriteData","matRef","spriteRef","timerOffset","window","performance","now","currentFrame","currentFrameName","fpsInterval","spriteTexture","setSpriteTexture","useState","Texture","totalFrames","aspect","setAspect","Vector3","flipOffset","pauseRef","pos","softEnd","spriteObj","loadJsonAndTexture","undefined","frameNameRef","parseSpriteDataLite","useCallback","textureData","current","_spriteData$current$f","_spriteData$current","Array","isArray","frames","length","w","h","sourceSize","calculateAspectRatio","map","modifySpritePosition","meta","size","metaInfo","frameW","frameH","wrapS","wrapT","RepeatWrapping","center","set","repeat","framesV","frameOffsetY","x","y","state","useMemo","imageUrl","hasEnded","useImperativeHandle","useLayoutEffect","width","height","_spriteRef$current","ret","aspectRatio","scale","copy","useEffect","_spriteDataset$sprite","clone","_spriteObj$spriteText","_ref","_aspect","runAnimation","spriteFrames","_endFrame","_offset","calculateFinalPosition","diff","endCondition","onStartCondition","manualProgressEndCondition","targetFrame","finalValX","finalValY","framesH","Math","round","frame","frameX","frameY","originalSizeX","originalSizeY","frameOffsetX","abs","frameIndex","floor","max","min","isNaN","_state","_delta","_spriteData$current2","_matRef$current","multiplyScale","initialScale","arguments","newScale","multiplyScalar","multiply","createElement","Provider","value","premultipliedAlpha","toneMapped","side","DoubleSide","transparent","limit","item","index","key","position"],"sources":["C:/Users/pishroo/CascadeProjects/3d-interior-designer/frontend/node_modules/@react-three/drei/core/SpriteAnimator.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { Instances, Instance } from './Instances.js';\nimport { Billboard } from './Billboard.js';\nimport { useSpriteLoader, getFirstFrame } from './useSpriteLoader.js';\n\n// Frame-related types\n\nconst context = /*#__PURE__*/React.createContext(null);\nfunction useSpriteAnimator() {\n  return React.useContext(context);\n}\n\n// Type guard for SpriteData\nfunction isSpriteData(data) {\n  return data !== null && 'meta' in data && 'frames' in data;\n}\nconst geometry = new THREE.PlaneGeometry(1, 1);\nconst SpriteAnimator = /* @__PURE__ */React.forwardRef(({\n  startFrame = 0,\n  endFrame,\n  fps = 30,\n  frameName = '',\n  textureDataURL,\n  textureImageURL,\n  loop = false,\n  numberOfFrames = 1,\n  autoPlay = true,\n  animationNames,\n  onStart,\n  onEnd,\n  onLoopEnd,\n  onFrame,\n  play,\n  pause = false,\n  flipX = false,\n  alphaTest = 0.0,\n  children,\n  asSprite = false,\n  offset,\n  playBackwards = false,\n  resetOnEnd = false,\n  maxItems = 1,\n  instanceItems = [[0, 0, 0]],\n  spriteDataset,\n  canvasRenderingContext2DSettings,\n  roundFramePosition = false,\n  meshProps = {},\n  ...props\n}, fref) => {\n  const ref = React.useRef(new THREE.Group());\n  const spriteData = React.useRef(null);\n  const matRef = React.useRef(null);\n  const spriteRef = React.useRef(null);\n  const timerOffset = React.useRef(window.performance.now());\n  const currentFrame = React.useRef(startFrame);\n  const currentFrameName = React.useRef(frameName);\n  const fpsInterval = fps > 0 ? 1000 / fps : 0;\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const totalFrames = React.useRef(0);\n  const [aspect, setAspect] = React.useState(new THREE.Vector3(1, 1, 1));\n  const flipOffset = flipX ? -1 : 1;\n  const pauseRef = React.useRef(pause);\n  const pos = React.useRef(offset);\n  const softEnd = React.useRef(false);\n  const {\n    spriteObj,\n    loadJsonAndTexture\n  } = useSpriteLoader(null, null, animationNames, numberOfFrames, undefined, canvasRenderingContext2DSettings);\n  const frameNameRef = React.useRef(frameName);\n\n  // lite version for pre-loaded assets\n  const parseSpriteDataLite = React.useCallback((textureData, data) => {\n    if (data === null) {\n      if (numberOfFrames) {\n        //get size from texture\n\n        totalFrames.current = numberOfFrames;\n        if (playBackwards) {\n          currentFrame.current = numberOfFrames - 1;\n        }\n        spriteData.current = data;\n      }\n    } else {\n      var _spriteData$current$f, _spriteData$current;\n      spriteData.current = data;\n      if (spriteData.current && Array.isArray(spriteData.current.frames)) {\n        totalFrames.current = spriteData.current.frames.length;\n      } else if (spriteData.current && typeof spriteData.current === 'object' && frameNameRef.current) {\n        totalFrames.current = spriteData.current.frames[frameNameRef.current].length;\n      } else {\n        totalFrames.current = 0;\n      }\n      if (playBackwards) {\n        currentFrame.current = totalFrames.current - 1;\n      }\n      const {\n        w,\n        h\n      } = getFirstFrame((_spriteData$current$f = (_spriteData$current = spriteData.current) == null ? void 0 : _spriteData$current.frames) !== null && _spriteData$current$f !== void 0 ? _spriteData$current$f : [], frameNameRef.current).sourceSize;\n      const aspect = calculateAspectRatio(w, h);\n      setAspect(aspect);\n      if (matRef.current) {\n        matRef.current.map = textureData;\n      }\n    }\n    setSpriteTexture(textureData);\n  }, [numberOfFrames, playBackwards]);\n\n  // modify the sprite material after json is parsed and state updated\n  const modifySpritePosition = React.useCallback(() => {\n    if (!spriteData.current) return;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = Array.isArray(frames) ? frames[0].sourceSize : frameName ? frames[frameName] ? frames[frameName][0].sourceSize : {\n      w: 0,\n      h: 0\n    } : {\n      w: 0,\n      h: 0\n    };\n    if (matRef.current && matRef.current.map) {\n      matRef.current.map.wrapS = matRef.current.map.wrapT = THREE.RepeatWrapping;\n      matRef.current.map.center.set(0, 0);\n      matRef.current.map.repeat.set(1 * flipOffset / (metaInfo.w / frameW), 1 / (metaInfo.h / frameH));\n    }\n    //const framesH = (metaInfo.w - 1) / frameW\n    const framesV = (metaInfo.h - 1) / frameH;\n    const frameOffsetY = 1 / framesV;\n    if (matRef.current && matRef.current.map) {\n      matRef.current.map.offset.x = 0.0; //-matRef.current.map.repeat.x\n      matRef.current.map.offset.y = 1 - frameOffsetY;\n    }\n    if (onStart) {\n      onStart({\n        currentFrameName: frameName !== null && frameName !== void 0 ? frameName : '',\n        currentFrame: currentFrame.current\n      });\n    }\n  }, [flipOffset, frameName, onStart]);\n  const state = React.useMemo(() => ({\n    current: pos.current,\n    offset: pos.current,\n    imageUrl: textureImageURL,\n    hasEnded: false,\n    ref: fref\n  }), [textureImageURL, fref]);\n  React.useImperativeHandle(fref, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    pos.current = offset;\n  }, [offset]);\n  const calculateAspectRatio = (width, height) => {\n    var _spriteRef$current;\n    const ret = new THREE.Vector3();\n    const aspectRatio = height / width;\n    ret.set(1, aspectRatio, 1);\n    (_spriteRef$current = spriteRef.current) == null || _spriteRef$current.scale.copy(ret);\n    return ret;\n  };\n\n  // initial loads\n  React.useEffect(() => {\n    if (spriteDataset) {\n      var _spriteDataset$sprite;\n      parseSpriteDataLite(spriteDataset == null || (_spriteDataset$sprite = spriteDataset.spriteTexture) == null ? void 0 : _spriteDataset$sprite.clone(), spriteDataset.spriteData);\n    } else {\n      if (textureImageURL && textureDataURL) {\n        loadJsonAndTexture(textureImageURL, textureDataURL);\n      }\n    }\n  }, [loadJsonAndTexture, spriteDataset, textureDataURL, textureImageURL, parseSpriteDataLite]);\n  React.useEffect(() => {\n    if (spriteObj) {\n      var _spriteObj$spriteText;\n      parseSpriteDataLite(spriteObj == null || (_spriteObj$spriteText = spriteObj.spriteTexture) == null ? void 0 : _spriteObj$spriteText.clone(), spriteObj == null ? void 0 : spriteObj.spriteData);\n    }\n  }, [spriteObj, parseSpriteDataLite]);\n\n  // support backwards play\n  React.useEffect(() => {\n    state.hasEnded = false;\n    if (spriteData.current && playBackwards === true) {\n      var _ref;\n      currentFrame.current = ((_ref = spriteData.current.frames.length) !== null && _ref !== void 0 ? _ref : 0) - 1;\n    } else {\n      currentFrame.current = 0;\n    }\n  }, [playBackwards, state]);\n  React.useLayoutEffect(() => {\n    modifySpritePosition();\n  }, [spriteTexture, flipX, modifySpritePosition]);\n  React.useEffect(() => {\n    if (autoPlay) {\n      pauseRef.current = false;\n    }\n  }, [autoPlay]);\n  React.useLayoutEffect(() => {\n    if (currentFrameName.current !== frameName && frameName) {\n      currentFrame.current = 0;\n      currentFrameName.current = frameName;\n      state.hasEnded = false;\n      if (fpsInterval <= 0) {\n        currentFrame.current = endFrame || startFrame || 0;\n      }\n      // modifySpritePosition()\n      if (spriteData.current) {\n        const {\n          w,\n          h\n        } = getFirstFrame(spriteData.current.frames, frameName).sourceSize;\n        const _aspect = calculateAspectRatio(w, h);\n        setAspect(_aspect);\n      }\n    }\n  }, [frameName, fpsInterval, state, endFrame, startFrame]);\n\n  // run the animation on each frame\n  const runAnimation = () => {\n    if (!isSpriteData(spriteData.current)) return;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = getFirstFrame(frames, frameName).sourceSize;\n    const spriteFrames = Array.isArray(frames) ? frames : frameName ? frames[frameName] : [];\n    const _endFrame = endFrame || spriteFrames.length - 1;\n    var _offset = offset === undefined ? state.current : offset;\n    if (fpsInterval <= 0) {\n      currentFrame.current = endFrame || startFrame || 0;\n      calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n      return;\n    }\n    const now = window.performance.now();\n    const diff = now - timerOffset.current;\n    if (diff <= fpsInterval) return;\n\n    // conditionals to support backwards play\n    var endCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current > _endFrame;\n    var onStartCondition = playBackwards ? currentFrame.current === _endFrame : currentFrame.current === 0;\n    var manualProgressEndCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current >= _endFrame;\n    if (endCondition) {\n      currentFrame.current = loop ? startFrame !== null && startFrame !== void 0 ? startFrame : 0 : 0;\n      if (playBackwards) {\n        currentFrame.current = _endFrame;\n      }\n      if (loop) {\n        onLoopEnd == null || onLoopEnd({\n          currentFrameName: frameName !== null && frameName !== void 0 ? frameName : '',\n          currentFrame: currentFrame.current\n        });\n      } else {\n        onEnd == null || onEnd({\n          currentFrameName: frameName !== null && frameName !== void 0 ? frameName : '',\n          currentFrame: currentFrame.current\n        });\n        state.hasEnded = !resetOnEnd;\n        if (resetOnEnd) {\n          pauseRef.current = true;\n          //calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames)\n        }\n      }\n      if (!loop) return;\n    } else if (onStartCondition) {\n      onStart == null || onStart({\n        currentFrameName: frameName !== null && frameName !== void 0 ? frameName : '',\n        currentFrame: currentFrame.current\n      });\n    }\n\n    // for manual update\n    if (_offset !== undefined && manualProgressEndCondition) {\n      if (softEnd.current === false) {\n        onEnd == null || onEnd({\n          currentFrameName: frameName !== null && frameName !== void 0 ? frameName : '',\n          currentFrame: currentFrame.current\n        });\n        softEnd.current = true;\n      }\n    } else {\n      // same for start?\n      softEnd.current = false;\n    }\n\n    // clock to limit fps\n    if (diff <= fpsInterval) return;\n    timerOffset.current = now - diff % fpsInterval;\n    calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n  };\n  const calculateFinalPosition = (frameW, frameH, metaInfo, spriteFrames) => {\n    // get the manual update offset to find the next frame\n    var _offset = offset === undefined ? state.current : offset;\n    const targetFrame = currentFrame.current;\n    let finalValX = 0;\n    let finalValY = 0;\n    calculateAspectRatio(frameW, frameH);\n    const framesH = roundFramePosition ? Math.round((metaInfo.w - 1) / frameW) : (metaInfo.w - 1) / frameW;\n    const framesV = roundFramePosition ? Math.round((metaInfo.h - 1) / frameH) : (metaInfo.h - 1) / frameH;\n    if (!spriteFrames[targetFrame]) {\n      return;\n    }\n    const {\n      frame: {\n        x: frameX,\n        y: frameY\n      },\n      sourceSize: {\n        w: originalSizeX,\n        h: originalSizeY\n      }\n    } = spriteFrames[targetFrame];\n    const frameOffsetX = 1 / framesH;\n    const frameOffsetY = 1 / framesV;\n    if (matRef.current && matRef.current.map) {\n      finalValX = flipOffset > 0 ? frameOffsetX * (frameX / originalSizeX) : frameOffsetX * (frameX / originalSizeX) - matRef.current.map.repeat.x;\n      finalValY = Math.abs(1 - frameOffsetY) - frameOffsetY * (frameY / originalSizeY);\n      matRef.current.map.offset.x = finalValX;\n      matRef.current.map.offset.y = finalValY;\n    }\n\n    // if manual update is active\n    if (_offset !== undefined && _offset !== null) {\n      // Calculate the frame index, based on offset given from the provider\n      let frameIndex = Math.floor(_offset * spriteFrames.length);\n\n      // Ensure the frame index is within the valid range\n      frameIndex = Math.max(0, Math.min(frameIndex, spriteFrames.length - 1));\n      if (isNaN(frameIndex)) {\n        frameIndex = 0; //fallback\n      }\n      currentFrame.current = frameIndex;\n    } else {\n      // auto update\n      if (playBackwards) {\n        currentFrame.current -= 1;\n      } else {\n        currentFrame.current += 1;\n      }\n    }\n  };\n\n  // *** Warning! It runs on every frame! ***\n  useFrame((_state, _delta) => {\n    var _spriteData$current2, _matRef$current;\n    if (!((_spriteData$current2 = spriteData.current) != null && _spriteData$current2.frames) || !((_matRef$current = matRef.current) != null && _matRef$current.map)) {\n      return;\n    }\n    if (pauseRef.current) {\n      return;\n    }\n    if (!state.hasEnded && (autoPlay || play)) {\n      runAnimation();\n      onFrame == null || onFrame({\n        currentFrameName: currentFrameName.current,\n        currentFrame: currentFrame.current\n      });\n    }\n  });\n  function multiplyScale(initialScale = new THREE.Vector3(1, 1, 1), newScale = 1) {\n    if (typeof newScale === 'number') return initialScale.multiplyScalar(newScale);\n    if (Array.isArray(newScale)) return initialScale.multiply(new THREE.Vector3(...newScale));\n    if (newScale instanceof THREE.Vector3) return initialScale.multiply(newScale);\n  }\n  return /*#__PURE__*/React.createElement(\"group\", _extends({}, props, {\n    ref: ref,\n    scale: multiplyScale(aspect, props.scale)\n  }), /*#__PURE__*/React.createElement(context.Provider, {\n    value: state\n  }, asSprite && /*#__PURE__*/React.createElement(Billboard, null, /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: spriteRef,\n    scale: 1.0,\n    geometry: geometry\n  }, meshProps), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    premultipliedAlpha: false,\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }))), !asSprite && /*#__PURE__*/React.createElement(Instances, _extends({\n    geometry: geometry,\n    limit: maxItems !== null && maxItems !== void 0 ? maxItems : 1\n  }, meshProps), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    premultipliedAlpha: false,\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }), (instanceItems !== null && instanceItems !== void 0 ? instanceItems : [0]).map((item, index) => /*#__PURE__*/React.createElement(Instance, _extends({\n    key: index,\n    ref: (instanceItems == null ? void 0 : instanceItems.length) === 1 ? spriteRef : null,\n    position: item,\n    scale: 1.0\n  }, meshProps)))), children));\n});\n\nexport { SpriteAnimator, useSpriteAnimator };\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,oCAAoC;AACzD,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,QAAQ,QAAQ,oBAAoB;AAC7C,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,SAAS,EAAEC,QAAQ,QAAQ,gBAAgB;AACpD,SAASC,SAAS,QAAQ,gBAAgB;AAC1C,SAASC,eAAe,EAAEC,aAAa,QAAQ,sBAAsB;;AAErE;;AAEA,MAAMC,OAAO,GAAG,aAAaR,KAAK,CAACS,aAAa,CAAC,IAAI,CAAC;AACtD,SAASC,iBAAiBA,CAAA,EAAG;EAC3B,OAAOV,KAAK,CAACW,UAAU,CAACH,OAAO,CAAC;AAClC;;AAEA;AACA,SAASI,YAAYA,CAACC,IAAI,EAAE;EAC1B,OAAOA,IAAI,KAAK,IAAI,IAAI,MAAM,IAAIA,IAAI,IAAI,QAAQ,IAAIA,IAAI;AAC5D;AACA,MAAMC,QAAQ,GAAG,IAAIZ,KAAK,CAACa,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC;AAC9C,MAAMC,cAAc,GAAG,eAAehB,KAAK,CAACiB,UAAU,CAAC,CAAAC,KAAA,EA+BpDC,IAAI,KAAK;EAAA,IA/B4C;IACtDC,UAAU,GAAG,CAAC;IACdC,QAAQ;IACRC,GAAG,GAAG,EAAE;IACRC,SAAS,GAAG,EAAE;IACdC,cAAc;IACdC,eAAe;IACfC,IAAI,GAAG,KAAK;IACZC,cAAc,GAAG,CAAC;IAClBC,QAAQ,GAAG,IAAI;IACfC,cAAc;IACdC,OAAO;IACPC,KAAK;IACLC,SAAS;IACTC,OAAO;IACPC,IAAI;IACJC,KAAK,GAAG,KAAK;IACbC,KAAK,GAAG,KAAK;IACbC,SAAS,GAAG,GAAG;IACfC,QAAQ;IACRC,QAAQ,GAAG,KAAK;IAChBC,MAAM;IACNC,aAAa,GAAG,KAAK;IACrBC,UAAU,GAAG,KAAK;IAClBC,QAAQ,GAAG,CAAC;IACZC,aAAa,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAC3BC,aAAa;IACbC,gCAAgC;IAChCC,kBAAkB,GAAG,KAAK;IAC1BC,SAAS,GAAG,CAAC,CAAC;IACd,GAAGC;EACL,CAAC,GAAA/B,KAAA;EACC,MAAMgC,GAAG,GAAGlD,KAAK,CAACmD,MAAM,CAAC,IAAIjD,KAAK,CAACkD,KAAK,CAAC,CAAC,CAAC;EAC3C,MAAMC,UAAU,GAAGrD,KAAK,CAACmD,MAAM,CAAC,IAAI,CAAC;EACrC,MAAMG,MAAM,GAAGtD,KAAK,CAACmD,MAAM,CAAC,IAAI,CAAC;EACjC,MAAMI,SAAS,GAAGvD,KAAK,CAACmD,MAAM,CAAC,IAAI,CAAC;EACpC,MAAMK,WAAW,GAAGxD,KAAK,CAACmD,MAAM,CAACM,MAAM,CAACC,WAAW,CAACC,GAAG,CAAC,CAAC,CAAC;EAC1D,MAAMC,YAAY,GAAG5D,KAAK,CAACmD,MAAM,CAAC/B,UAAU,CAAC;EAC7C,MAAMyC,gBAAgB,GAAG7D,KAAK,CAACmD,MAAM,CAAC5B,SAAS,CAAC;EAChD,MAAMuC,WAAW,GAAGxC,GAAG,GAAG,CAAC,GAAG,IAAI,GAAGA,GAAG,GAAG,CAAC;EAC5C,MAAM,CAACyC,aAAa,EAAEC,gBAAgB,CAAC,GAAGhE,KAAK,CAACiE,QAAQ,CAAC,IAAI/D,KAAK,CAACgE,OAAO,CAAC,CAAC,CAAC;EAC7E,MAAMC,WAAW,GAAGnE,KAAK,CAACmD,MAAM,CAAC,CAAC,CAAC;EACnC,MAAM,CAACiB,MAAM,EAAEC,SAAS,CAAC,GAAGrE,KAAK,CAACiE,QAAQ,CAAC,IAAI/D,KAAK,CAACoE,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EACtE,MAAMC,UAAU,GAAGnC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC;EACjC,MAAMoC,QAAQ,GAAGxE,KAAK,CAACmD,MAAM,CAAChB,KAAK,CAAC;EACpC,MAAMsC,GAAG,GAAGzE,KAAK,CAACmD,MAAM,CAACX,MAAM,CAAC;EAChC,MAAMkC,OAAO,GAAG1E,KAAK,CAACmD,MAAM,CAAC,KAAK,CAAC;EACnC,MAAM;IACJwB,SAAS;IACTC;EACF,CAAC,GAAGtE,eAAe,CAAC,IAAI,EAAE,IAAI,EAAEuB,cAAc,EAAEF,cAAc,EAAEkD,SAAS,EAAE/B,gCAAgC,CAAC;EAC5G,MAAMgC,YAAY,GAAG9E,KAAK,CAACmD,MAAM,CAAC5B,SAAS,CAAC;;EAE5C;EACA,MAAMwD,mBAAmB,GAAG/E,KAAK,CAACgF,WAAW,CAAC,CAACC,WAAW,EAAEpE,IAAI,KAAK;IACnE,IAAIA,IAAI,KAAK,IAAI,EAAE;MACjB,IAAIc,cAAc,EAAE;QAClB;;QAEAwC,WAAW,CAACe,OAAO,GAAGvD,cAAc;QACpC,IAAIc,aAAa,EAAE;UACjBmB,YAAY,CAACsB,OAAO,GAAGvD,cAAc,GAAG,CAAC;QAC3C;QACA0B,UAAU,CAAC6B,OAAO,GAAGrE,IAAI;MAC3B;IACF,CAAC,MAAM;MACL,IAAIsE,qBAAqB,EAAEC,mBAAmB;MAC9C/B,UAAU,CAAC6B,OAAO,GAAGrE,IAAI;MACzB,IAAIwC,UAAU,CAAC6B,OAAO,IAAIG,KAAK,CAACC,OAAO,CAACjC,UAAU,CAAC6B,OAAO,CAACK,MAAM,CAAC,EAAE;QAClEpB,WAAW,CAACe,OAAO,GAAG7B,UAAU,CAAC6B,OAAO,CAACK,MAAM,CAACC,MAAM;MACxD,CAAC,MAAM,IAAInC,UAAU,CAAC6B,OAAO,IAAI,OAAO7B,UAAU,CAAC6B,OAAO,KAAK,QAAQ,IAAIJ,YAAY,CAACI,OAAO,EAAE;QAC/Ff,WAAW,CAACe,OAAO,GAAG7B,UAAU,CAAC6B,OAAO,CAACK,MAAM,CAACT,YAAY,CAACI,OAAO,CAAC,CAACM,MAAM;MAC9E,CAAC,MAAM;QACLrB,WAAW,CAACe,OAAO,GAAG,CAAC;MACzB;MACA,IAAIzC,aAAa,EAAE;QACjBmB,YAAY,CAACsB,OAAO,GAAGf,WAAW,CAACe,OAAO,GAAG,CAAC;MAChD;MACA,MAAM;QACJO,CAAC;QACDC;MACF,CAAC,GAAGnF,aAAa,CAAC,CAAC4E,qBAAqB,GAAG,CAACC,mBAAmB,GAAG/B,UAAU,CAAC6B,OAAO,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGE,mBAAmB,CAACG,MAAM,MAAM,IAAI,IAAIJ,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAG,EAAE,EAAEL,YAAY,CAACI,OAAO,CAAC,CAACS,UAAU;MAChP,MAAMvB,MAAM,GAAGwB,oBAAoB,CAACH,CAAC,EAAEC,CAAC,CAAC;MACzCrB,SAAS,CAACD,MAAM,CAAC;MACjB,IAAId,MAAM,CAAC4B,OAAO,EAAE;QAClB5B,MAAM,CAAC4B,OAAO,CAACW,GAAG,GAAGZ,WAAW;MAClC;IACF;IACAjB,gBAAgB,CAACiB,WAAW,CAAC;EAC/B,CAAC,EAAE,CAACtD,cAAc,EAAEc,aAAa,CAAC,CAAC;;EAEnC;EACA,MAAMqD,oBAAoB,GAAG9F,KAAK,CAACgF,WAAW,CAAC,MAAM;IACnD,IAAI,CAAC3B,UAAU,CAAC6B,OAAO,EAAE;IACzB,MAAM;MACJa,IAAI,EAAE;QACJC,IAAI,EAAEC;MACR,CAAC;MACDV;IACF,CAAC,GAAGlC,UAAU,CAAC6B,OAAO;IACtB,MAAM;MACJO,CAAC,EAAES,MAAM;MACTR,CAAC,EAAES;IACL,CAAC,GAAGd,KAAK,CAACC,OAAO,CAACC,MAAM,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,CAACI,UAAU,GAAGpE,SAAS,GAAGgE,MAAM,CAAChE,SAAS,CAAC,GAAGgE,MAAM,CAAChE,SAAS,CAAC,CAAC,CAAC,CAAC,CAACoE,UAAU,GAAG;MACnHF,CAAC,EAAE,CAAC;MACJC,CAAC,EAAE;IACL,CAAC,GAAG;MACFD,CAAC,EAAE,CAAC;MACJC,CAAC,EAAE;IACL,CAAC;IACD,IAAIpC,MAAM,CAAC4B,OAAO,IAAI5B,MAAM,CAAC4B,OAAO,CAACW,GAAG,EAAE;MACxCvC,MAAM,CAAC4B,OAAO,CAACW,GAAG,CAACO,KAAK,GAAG9C,MAAM,CAAC4B,OAAO,CAACW,GAAG,CAACQ,KAAK,GAAGnG,KAAK,CAACoG,cAAc;MAC1EhD,MAAM,CAAC4B,OAAO,CAACW,GAAG,CAACU,MAAM,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;MACnClD,MAAM,CAAC4B,OAAO,CAACW,GAAG,CAACY,MAAM,CAACD,GAAG,CAAC,CAAC,GAAGjC,UAAU,IAAI0B,QAAQ,CAACR,CAAC,GAAGS,MAAM,CAAC,EAAE,CAAC,IAAID,QAAQ,CAACP,CAAC,GAAGS,MAAM,CAAC,CAAC;IAClG;IACA;IACA,MAAMO,OAAO,GAAG,CAACT,QAAQ,CAACP,CAAC,GAAG,CAAC,IAAIS,MAAM;IACzC,MAAMQ,YAAY,GAAG,CAAC,GAAGD,OAAO;IAChC,IAAIpD,MAAM,CAAC4B,OAAO,IAAI5B,MAAM,CAAC4B,OAAO,CAACW,GAAG,EAAE;MACxCvC,MAAM,CAAC4B,OAAO,CAACW,GAAG,CAACrD,MAAM,CAACoE,CAAC,GAAG,GAAG,CAAC,CAAC;MACnCtD,MAAM,CAAC4B,OAAO,CAACW,GAAG,CAACrD,MAAM,CAACqE,CAAC,GAAG,CAAC,GAAGF,YAAY;IAChD;IACA,IAAI7E,OAAO,EAAE;MACXA,OAAO,CAAC;QACN+B,gBAAgB,EAAEtC,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAG,EAAE;QAC7EqC,YAAY,EAAEA,YAAY,CAACsB;MAC7B,CAAC,CAAC;IACJ;EACF,CAAC,EAAE,CAACX,UAAU,EAAEhD,SAAS,EAAEO,OAAO,CAAC,CAAC;EACpC,MAAMgF,KAAK,GAAG9G,KAAK,CAAC+G,OAAO,CAAC,OAAO;IACjC7B,OAAO,EAAET,GAAG,CAACS,OAAO;IACpB1C,MAAM,EAAEiC,GAAG,CAACS,OAAO;IACnB8B,QAAQ,EAAEvF,eAAe;IACzBwF,QAAQ,EAAE,KAAK;IACf/D,GAAG,EAAE/B;EACP,CAAC,CAAC,EAAE,CAACM,eAAe,EAAEN,IAAI,CAAC,CAAC;EAC5BnB,KAAK,CAACkH,mBAAmB,CAAC/F,IAAI,EAAE,MAAM+B,GAAG,CAACgC,OAAO,EAAE,EAAE,CAAC;EACtDlF,KAAK,CAACmH,eAAe,CAAC,MAAM;IAC1B1C,GAAG,CAACS,OAAO,GAAG1C,MAAM;EACtB,CAAC,EAAE,CAACA,MAAM,CAAC,CAAC;EACZ,MAAMoD,oBAAoB,GAAGA,CAACwB,KAAK,EAAEC,MAAM,KAAK;IAC9C,IAAIC,kBAAkB;IACtB,MAAMC,GAAG,GAAG,IAAIrH,KAAK,CAACoE,OAAO,CAAC,CAAC;IAC/B,MAAMkD,WAAW,GAAGH,MAAM,GAAGD,KAAK;IAClCG,GAAG,CAACf,GAAG,CAAC,CAAC,EAAEgB,WAAW,EAAE,CAAC,CAAC;IAC1B,CAACF,kBAAkB,GAAG/D,SAAS,CAAC2B,OAAO,KAAK,IAAI,IAAIoC,kBAAkB,CAACG,KAAK,CAACC,IAAI,CAACH,GAAG,CAAC;IACtF,OAAOA,GAAG;EACZ,CAAC;;EAED;EACAvH,KAAK,CAAC2H,SAAS,CAAC,MAAM;IACpB,IAAI9E,aAAa,EAAE;MACjB,IAAI+E,qBAAqB;MACzB7C,mBAAmB,CAAClC,aAAa,IAAI,IAAI,IAAI,CAAC+E,qBAAqB,GAAG/E,aAAa,CAACkB,aAAa,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG6D,qBAAqB,CAACC,KAAK,CAAC,CAAC,EAAEhF,aAAa,CAACQ,UAAU,CAAC;IAChL,CAAC,MAAM;MACL,IAAI5B,eAAe,IAAID,cAAc,EAAE;QACrCoD,kBAAkB,CAACnD,eAAe,EAAED,cAAc,CAAC;MACrD;IACF;EACF,CAAC,EAAE,CAACoD,kBAAkB,EAAE/B,aAAa,EAAErB,cAAc,EAAEC,eAAe,EAAEsD,mBAAmB,CAAC,CAAC;EAC7F/E,KAAK,CAAC2H,SAAS,CAAC,MAAM;IACpB,IAAIhD,SAAS,EAAE;MACb,IAAImD,qBAAqB;MACzB/C,mBAAmB,CAACJ,SAAS,IAAI,IAAI,IAAI,CAACmD,qBAAqB,GAAGnD,SAAS,CAACZ,aAAa,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG+D,qBAAqB,CAACD,KAAK,CAAC,CAAC,EAAElD,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACtB,UAAU,CAAC;IACjM;EACF,CAAC,EAAE,CAACsB,SAAS,EAAEI,mBAAmB,CAAC,CAAC;;EAEpC;EACA/E,KAAK,CAAC2H,SAAS,CAAC,MAAM;IACpBb,KAAK,CAACG,QAAQ,GAAG,KAAK;IACtB,IAAI5D,UAAU,CAAC6B,OAAO,IAAIzC,aAAa,KAAK,IAAI,EAAE;MAChD,IAAIsF,IAAI;MACRnE,YAAY,CAACsB,OAAO,GAAG,CAAC,CAAC6C,IAAI,GAAG1E,UAAU,CAAC6B,OAAO,CAACK,MAAM,CAACC,MAAM,MAAM,IAAI,IAAIuC,IAAI,KAAK,KAAK,CAAC,GAAGA,IAAI,GAAG,CAAC,IAAI,CAAC;IAC/G,CAAC,MAAM;MACLnE,YAAY,CAACsB,OAAO,GAAG,CAAC;IAC1B;EACF,CAAC,EAAE,CAACzC,aAAa,EAAEqE,KAAK,CAAC,CAAC;EAC1B9G,KAAK,CAACmH,eAAe,CAAC,MAAM;IAC1BrB,oBAAoB,CAAC,CAAC;EACxB,CAAC,EAAE,CAAC/B,aAAa,EAAE3B,KAAK,EAAE0D,oBAAoB,CAAC,CAAC;EAChD9F,KAAK,CAAC2H,SAAS,CAAC,MAAM;IACpB,IAAI/F,QAAQ,EAAE;MACZ4C,QAAQ,CAACU,OAAO,GAAG,KAAK;IAC1B;EACF,CAAC,EAAE,CAACtD,QAAQ,CAAC,CAAC;EACd5B,KAAK,CAACmH,eAAe,CAAC,MAAM;IAC1B,IAAItD,gBAAgB,CAACqB,OAAO,KAAK3D,SAAS,IAAIA,SAAS,EAAE;MACvDqC,YAAY,CAACsB,OAAO,GAAG,CAAC;MACxBrB,gBAAgB,CAACqB,OAAO,GAAG3D,SAAS;MACpCuF,KAAK,CAACG,QAAQ,GAAG,KAAK;MACtB,IAAInD,WAAW,IAAI,CAAC,EAAE;QACpBF,YAAY,CAACsB,OAAO,GAAG7D,QAAQ,IAAID,UAAU,IAAI,CAAC;MACpD;MACA;MACA,IAAIiC,UAAU,CAAC6B,OAAO,EAAE;QACtB,MAAM;UACJO,CAAC;UACDC;QACF,CAAC,GAAGnF,aAAa,CAAC8C,UAAU,CAAC6B,OAAO,CAACK,MAAM,EAAEhE,SAAS,CAAC,CAACoE,UAAU;QAClE,MAAMqC,OAAO,GAAGpC,oBAAoB,CAACH,CAAC,EAAEC,CAAC,CAAC;QAC1CrB,SAAS,CAAC2D,OAAO,CAAC;MACpB;IACF;EACF,CAAC,EAAE,CAACzG,SAAS,EAAEuC,WAAW,EAAEgD,KAAK,EAAEzF,QAAQ,EAAED,UAAU,CAAC,CAAC;;EAEzD;EACA,MAAM6G,YAAY,GAAGA,CAAA,KAAM;IACzB,IAAI,CAACrH,YAAY,CAACyC,UAAU,CAAC6B,OAAO,CAAC,EAAE;IACvC,MAAM;MACJa,IAAI,EAAE;QACJC,IAAI,EAAEC;MACR,CAAC;MACDV;IACF,CAAC,GAAGlC,UAAU,CAAC6B,OAAO;IACtB,MAAM;MACJO,CAAC,EAAES,MAAM;MACTR,CAAC,EAAES;IACL,CAAC,GAAG5F,aAAa,CAACgF,MAAM,EAAEhE,SAAS,CAAC,CAACoE,UAAU;IAC/C,MAAMuC,YAAY,GAAG7C,KAAK,CAACC,OAAO,CAACC,MAAM,CAAC,GAAGA,MAAM,GAAGhE,SAAS,GAAGgE,MAAM,CAAChE,SAAS,CAAC,GAAG,EAAE;IACxF,MAAM4G,SAAS,GAAG9G,QAAQ,IAAI6G,YAAY,CAAC1C,MAAM,GAAG,CAAC;IACrD,IAAI4C,OAAO,GAAG5F,MAAM,KAAKqC,SAAS,GAAGiC,KAAK,CAAC5B,OAAO,GAAG1C,MAAM;IAC3D,IAAIsB,WAAW,IAAI,CAAC,EAAE;MACpBF,YAAY,CAACsB,OAAO,GAAG7D,QAAQ,IAAID,UAAU,IAAI,CAAC;MAClDiH,sBAAsB,CAACnC,MAAM,EAAEC,MAAM,EAAEF,QAAQ,EAAEiC,YAAY,CAAC;MAC9D;IACF;IACA,MAAMvE,GAAG,GAAGF,MAAM,CAACC,WAAW,CAACC,GAAG,CAAC,CAAC;IACpC,MAAM2E,IAAI,GAAG3E,GAAG,GAAGH,WAAW,CAAC0B,OAAO;IACtC,IAAIoD,IAAI,IAAIxE,WAAW,EAAE;;IAEzB;IACA,IAAIyE,YAAY,GAAG9F,aAAa,GAAGmB,YAAY,CAACsB,OAAO,GAAG,CAAC,GAAGtB,YAAY,CAACsB,OAAO,GAAGiD,SAAS;IAC9F,IAAIK,gBAAgB,GAAG/F,aAAa,GAAGmB,YAAY,CAACsB,OAAO,KAAKiD,SAAS,GAAGvE,YAAY,CAACsB,OAAO,KAAK,CAAC;IACtG,IAAIuD,0BAA0B,GAAGhG,aAAa,GAAGmB,YAAY,CAACsB,OAAO,GAAG,CAAC,GAAGtB,YAAY,CAACsB,OAAO,IAAIiD,SAAS;IAC7G,IAAII,YAAY,EAAE;MAChB3E,YAAY,CAACsB,OAAO,GAAGxD,IAAI,GAAGN,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAGA,UAAU,GAAG,CAAC,GAAG,CAAC;MAC/F,IAAIqB,aAAa,EAAE;QACjBmB,YAAY,CAACsB,OAAO,GAAGiD,SAAS;MAClC;MACA,IAAIzG,IAAI,EAAE;QACRM,SAAS,IAAI,IAAI,IAAIA,SAAS,CAAC;UAC7B6B,gBAAgB,EAAEtC,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAG,EAAE;UAC7EqC,YAAY,EAAEA,YAAY,CAACsB;QAC7B,CAAC,CAAC;MACJ,CAAC,MAAM;QACLnD,KAAK,IAAI,IAAI,IAAIA,KAAK,CAAC;UACrB8B,gBAAgB,EAAEtC,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAG,EAAE;UAC7EqC,YAAY,EAAEA,YAAY,CAACsB;QAC7B,CAAC,CAAC;QACF4B,KAAK,CAACG,QAAQ,GAAG,CAACvE,UAAU;QAC5B,IAAIA,UAAU,EAAE;UACd8B,QAAQ,CAACU,OAAO,GAAG,IAAI;UACvB;QACF;MACF;MACA,IAAI,CAACxD,IAAI,EAAE;IACb,CAAC,MAAM,IAAI8G,gBAAgB,EAAE;MAC3B1G,OAAO,IAAI,IAAI,IAAIA,OAAO,CAAC;QACzB+B,gBAAgB,EAAEtC,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAG,EAAE;QAC7EqC,YAAY,EAAEA,YAAY,CAACsB;MAC7B,CAAC,CAAC;IACJ;;IAEA;IACA,IAAIkD,OAAO,KAAKvD,SAAS,IAAI4D,0BAA0B,EAAE;MACvD,IAAI/D,OAAO,CAACQ,OAAO,KAAK,KAAK,EAAE;QAC7BnD,KAAK,IAAI,IAAI,IAAIA,KAAK,CAAC;UACrB8B,gBAAgB,EAAEtC,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAG,EAAE;UAC7EqC,YAAY,EAAEA,YAAY,CAACsB;QAC7B,CAAC,CAAC;QACFR,OAAO,CAACQ,OAAO,GAAG,IAAI;MACxB;IACF,CAAC,MAAM;MACL;MACAR,OAAO,CAACQ,OAAO,GAAG,KAAK;IACzB;;IAEA;IACA,IAAIoD,IAAI,IAAIxE,WAAW,EAAE;IACzBN,WAAW,CAAC0B,OAAO,GAAGvB,GAAG,GAAG2E,IAAI,GAAGxE,WAAW;IAC9CuE,sBAAsB,CAACnC,MAAM,EAAEC,MAAM,EAAEF,QAAQ,EAAEiC,YAAY,CAAC;EAChE,CAAC;EACD,MAAMG,sBAAsB,GAAGA,CAACnC,MAAM,EAAEC,MAAM,EAAEF,QAAQ,EAAEiC,YAAY,KAAK;IACzE;IACA,IAAIE,OAAO,GAAG5F,MAAM,KAAKqC,SAAS,GAAGiC,KAAK,CAAC5B,OAAO,GAAG1C,MAAM;IAC3D,MAAMkG,WAAW,GAAG9E,YAAY,CAACsB,OAAO;IACxC,IAAIyD,SAAS,GAAG,CAAC;IACjB,IAAIC,SAAS,GAAG,CAAC;IACjBhD,oBAAoB,CAACM,MAAM,EAAEC,MAAM,CAAC;IACpC,MAAM0C,OAAO,GAAG9F,kBAAkB,GAAG+F,IAAI,CAACC,KAAK,CAAC,CAAC9C,QAAQ,CAACR,CAAC,GAAG,CAAC,IAAIS,MAAM,CAAC,GAAG,CAACD,QAAQ,CAACR,CAAC,GAAG,CAAC,IAAIS,MAAM;IACtG,MAAMQ,OAAO,GAAG3D,kBAAkB,GAAG+F,IAAI,CAACC,KAAK,CAAC,CAAC9C,QAAQ,CAACP,CAAC,GAAG,CAAC,IAAIS,MAAM,CAAC,GAAG,CAACF,QAAQ,CAACP,CAAC,GAAG,CAAC,IAAIS,MAAM;IACtG,IAAI,CAAC+B,YAAY,CAACQ,WAAW,CAAC,EAAE;MAC9B;IACF;IACA,MAAM;MACJM,KAAK,EAAE;QACLpC,CAAC,EAAEqC,MAAM;QACTpC,CAAC,EAAEqC;MACL,CAAC;MACDvD,UAAU,EAAE;QACVF,CAAC,EAAE0D,aAAa;QAChBzD,CAAC,EAAE0D;MACL;IACF,CAAC,GAAGlB,YAAY,CAACQ,WAAW,CAAC;IAC7B,MAAMW,YAAY,GAAG,CAAC,GAAGR,OAAO;IAChC,MAAMlC,YAAY,GAAG,CAAC,GAAGD,OAAO;IAChC,IAAIpD,MAAM,CAAC4B,OAAO,IAAI5B,MAAM,CAAC4B,OAAO,CAACW,GAAG,EAAE;MACxC8C,SAAS,GAAGpE,UAAU,GAAG,CAAC,GAAG8E,YAAY,IAAIJ,MAAM,GAAGE,aAAa,CAAC,GAAGE,YAAY,IAAIJ,MAAM,GAAGE,aAAa,CAAC,GAAG7F,MAAM,CAAC4B,OAAO,CAACW,GAAG,CAACY,MAAM,CAACG,CAAC;MAC5IgC,SAAS,GAAGE,IAAI,CAACQ,GAAG,CAAC,CAAC,GAAG3C,YAAY,CAAC,GAAGA,YAAY,IAAIuC,MAAM,GAAGE,aAAa,CAAC;MAChF9F,MAAM,CAAC4B,OAAO,CAACW,GAAG,CAACrD,MAAM,CAACoE,CAAC,GAAG+B,SAAS;MACvCrF,MAAM,CAAC4B,OAAO,CAACW,GAAG,CAACrD,MAAM,CAACqE,CAAC,GAAG+B,SAAS;IACzC;;IAEA;IACA,IAAIR,OAAO,KAAKvD,SAAS,IAAIuD,OAAO,KAAK,IAAI,EAAE;MAC7C;MACA,IAAImB,UAAU,GAAGT,IAAI,CAACU,KAAK,CAACpB,OAAO,GAAGF,YAAY,CAAC1C,MAAM,CAAC;;MAE1D;MACA+D,UAAU,GAAGT,IAAI,CAACW,GAAG,CAAC,CAAC,EAAEX,IAAI,CAACY,GAAG,CAACH,UAAU,EAAErB,YAAY,CAAC1C,MAAM,GAAG,CAAC,CAAC,CAAC;MACvE,IAAImE,KAAK,CAACJ,UAAU,CAAC,EAAE;QACrBA,UAAU,GAAG,CAAC,CAAC,CAAC;MAClB;MACA3F,YAAY,CAACsB,OAAO,GAAGqE,UAAU;IACnC,CAAC,MAAM;MACL;MACA,IAAI9G,aAAa,EAAE;QACjBmB,YAAY,CAACsB,OAAO,IAAI,CAAC;MAC3B,CAAC,MAAM;QACLtB,YAAY,CAACsB,OAAO,IAAI,CAAC;MAC3B;IACF;EACF,CAAC;;EAED;EACAjF,QAAQ,CAAC,CAAC2J,MAAM,EAAEC,MAAM,KAAK;IAC3B,IAAIC,oBAAoB,EAAEC,eAAe;IACzC,IAAI,EAAE,CAACD,oBAAoB,GAAGzG,UAAU,CAAC6B,OAAO,KAAK,IAAI,IAAI4E,oBAAoB,CAACvE,MAAM,CAAC,IAAI,EAAE,CAACwE,eAAe,GAAGzG,MAAM,CAAC4B,OAAO,KAAK,IAAI,IAAI6E,eAAe,CAAClE,GAAG,CAAC,EAAE;MACjK;IACF;IACA,IAAIrB,QAAQ,CAACU,OAAO,EAAE;MACpB;IACF;IACA,IAAI,CAAC4B,KAAK,CAACG,QAAQ,KAAKrF,QAAQ,IAAIM,IAAI,CAAC,EAAE;MACzC+F,YAAY,CAAC,CAAC;MACdhG,OAAO,IAAI,IAAI,IAAIA,OAAO,CAAC;QACzB4B,gBAAgB,EAAEA,gBAAgB,CAACqB,OAAO;QAC1CtB,YAAY,EAAEA,YAAY,CAACsB;MAC7B,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;EACF,SAAS8E,aAAaA,CAAA,EAA0D;IAAA,IAAzDC,YAAY,GAAAC,SAAA,CAAA1E,MAAA,QAAA0E,SAAA,QAAArF,SAAA,GAAAqF,SAAA,MAAG,IAAIhK,KAAK,CAACoE,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAAA,IAAE6F,QAAQ,GAAAD,SAAA,CAAA1E,MAAA,QAAA0E,SAAA,QAAArF,SAAA,GAAAqF,SAAA,MAAG,CAAC;IAC5E,IAAI,OAAOC,QAAQ,KAAK,QAAQ,EAAE,OAAOF,YAAY,CAACG,cAAc,CAACD,QAAQ,CAAC;IAC9E,IAAI9E,KAAK,CAACC,OAAO,CAAC6E,QAAQ,CAAC,EAAE,OAAOF,YAAY,CAACI,QAAQ,CAAC,IAAInK,KAAK,CAACoE,OAAO,CAAC,GAAG6F,QAAQ,CAAC,CAAC;IACzF,IAAIA,QAAQ,YAAYjK,KAAK,CAACoE,OAAO,EAAE,OAAO2F,YAAY,CAACI,QAAQ,CAACF,QAAQ,CAAC;EAC/E;EACA,OAAO,aAAanK,KAAK,CAACsK,aAAa,CAAC,OAAO,EAAEvK,QAAQ,CAAC,CAAC,CAAC,EAAEkD,KAAK,EAAE;IACnEC,GAAG,EAAEA,GAAG;IACRuE,KAAK,EAAEuC,aAAa,CAAC5F,MAAM,EAAEnB,KAAK,CAACwE,KAAK;EAC1C,CAAC,CAAC,EAAE,aAAazH,KAAK,CAACsK,aAAa,CAAC9J,OAAO,CAAC+J,QAAQ,EAAE;IACrDC,KAAK,EAAE1D;EACT,CAAC,EAAEvE,QAAQ,IAAI,aAAavC,KAAK,CAACsK,aAAa,CAACjK,SAAS,EAAE,IAAI,EAAE,aAAaL,KAAK,CAACsK,aAAa,CAAC,MAAM,EAAEvK,QAAQ,CAAC;IACjHmD,GAAG,EAAEK,SAAS;IACdkE,KAAK,EAAE,GAAG;IACV3G,QAAQ,EAAEA;EACZ,CAAC,EAAEkC,SAAS,CAAC,EAAE,aAAahD,KAAK,CAACsK,aAAa,CAAC,mBAAmB,EAAE;IACnEG,kBAAkB,EAAE,KAAK;IACzBC,UAAU,EAAE,KAAK;IACjBC,IAAI,EAAEzK,KAAK,CAAC0K,UAAU;IACtB1H,GAAG,EAAEI,MAAM;IACXuC,GAAG,EAAE9B,aAAa;IAClB8G,WAAW,EAAE,IAAI;IACjBxI,SAAS,EAAEA,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAG;EACtE,CAAC,CAAC,CAAC,CAAC,EAAE,CAACE,QAAQ,IAAI,aAAavC,KAAK,CAACsK,aAAa,CAACnK,SAAS,EAAEJ,QAAQ,CAAC;IACtEe,QAAQ,EAAEA,QAAQ;IAClBgK,KAAK,EAAEnI,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAGA,QAAQ,GAAG;EAC/D,CAAC,EAAEK,SAAS,CAAC,EAAE,aAAahD,KAAK,CAACsK,aAAa,CAAC,mBAAmB,EAAE;IACnEG,kBAAkB,EAAE,KAAK;IACzBC,UAAU,EAAE,KAAK;IACjBC,IAAI,EAAEzK,KAAK,CAAC0K,UAAU;IACtB1H,GAAG,EAAEI,MAAM;IACXuC,GAAG,EAAE9B,aAAa;IAClB8G,WAAW,EAAE,IAAI;IACjBxI,SAAS,EAAEA,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAG;EACtE,CAAC,CAAC,EAAE,CAACO,aAAa,KAAK,IAAI,IAAIA,aAAa,KAAK,KAAK,CAAC,GAAGA,aAAa,GAAG,CAAC,CAAC,CAAC,EAAEiD,GAAG,CAAC,CAACkF,IAAI,EAAEC,KAAK,KAAK,aAAahL,KAAK,CAACsK,aAAa,CAAClK,QAAQ,EAAEL,QAAQ,CAAC;IACtJkL,GAAG,EAAED,KAAK;IACV9H,GAAG,EAAE,CAACN,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAAC4C,MAAM,MAAM,CAAC,GAAGjC,SAAS,GAAG,IAAI;IACrF2H,QAAQ,EAAEH,IAAI;IACdtD,KAAK,EAAE;EACT,CAAC,EAAEzE,SAAS,CAAC,CAAC,CAAC,CAAC,EAAEV,QAAQ,CAAC,CAAC;AAC9B,CAAC,CAAC;AAEF,SAAStB,cAAc,EAAEN,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}